#Blinding Attack
from Crypto.Util.number import *
import random
m = bytes_to_long(b"Mr Tu give our group 1000$.")
print('m =', m)
r = random.randint(1,1000000)

p = 76150018324870293801626203368938380282028692734119809745329721688049744099807
q = 73162596038436026679625593603619491780904218775508635628346783945595639724353
e = 65537
n = p*q
phiN = (p-1)*(q-1)

d = inverse(e, phiN)
print('d =', d)
print('e =', e)
print('N =', n)
truesign = pow(m,d,n)

print('True sign: ')
print(truesign)

msgblind = (pow(r,e))*(m % n)

# print('Message: ')
# print(msgblind)

signblind = pow(msgblind, d, n)

# print('Mr.Tu has signed: ')
# print (signblind)
fakesign = pow(m,d,n)

print('Fake sign: ')
print(fakesign)

if (fakesign == truesign):
    print('Verify success.')

#Common Modulus
import gmpy2
from Crypto.Util.number import *
m = "This is the demonstration for Common Modulus Attack."
m1 = bytes_to_long(b"This is the demonstration for Common Modulus Attack.")
class RSAModuli:
    def __init__(self):
        self.a = 0
        self.b = 0
        self.m = m1
        self.i = 0
    def gcd(self, num1, num2):
        """
        This function os used to find the GCD of 2 numbers.
        :param num1:
        :param num2:
        :return:
        """
        if num1 < num2:
               num1, num2 = num2, num1
        while num2 != 0:
            num1, num2 = num2, num1 % num2
        return num1
    def extended_euclidean(self, e1, e2):
        """
        The value a is the modular multiplicative inverse of e1 and e2.
        b is calculated from the eqn: (e1*a) + (e2*b) = gcd(e1, e2)
        :param e1: exponent 1
        :param e2: exponent 2
        """
        self.a = gmpy2.invert(e1, e2)
        self.b = (float(self.gcd(e1, e2)-(self.a*e1)))/float(e2)
    def modular_inverse(self, c1, c2, N):
        """
        i is the modular multiplicative inverse of c2 and N.
        i^-b is equal to c2^b. So if the value of b is -ve, we
        have to find out i and then do i^-b.
        Final plain text is given by m = (c1^a) * (i^-b) %N
        :param c1: cipher text 1
        :param c2: cipher text 2
        :param N: Modulus
        """
        i = gmpy2.invert(c2, N)
        mx = pow(c1, self.a, N)
        my = pow(i, int(-self.b), N)
        self.m= mx * my % N
    def print_value(self):
        print("Plain Text: ", self.m)
        print(long_to_bytes(self.m))
        
   
   
def main():
    c = RSAModuli()
    N  = 163325259729739139586456854939342071588766536976661696628405612100543978684304953042431845499808366612030757037530278155957389217094639917994417350499882225626580260012564702898468467277918937337494297292631474713546289580689715170963879872522418640251986734692138838546500522994170062961577034037699354013013
    c1 = 139684804460574205849925080587628271972508627884035687947553941002113686623972010071511803349085611227542818456573909159991473487166694306341223785834160737236987903079930708230312445095391465486916281260895188333624952709172532300913276313831216020789160913413387619755289711293944732229489865983955307055991
    c2 = 120646513115873889137087098442391432414164546961443458330822859711946719770150594475944428083527059271734285314955836210501734699457158775633860998004225278778728260259508648270337214963124368260195050900519969497494258926769653713277923223239802202985841708520808573625900966031969645357847606623874003011950
    e1 = 9007
    e2 = 65537
    c.extended_euclidean(e1, e2)
    c.modular_inverse(c1, c2, N)
    c.print_value()
    
if __name__ == '__main__':
    main()

#Fermat Attack
from Crypto.Util.number import *
m = 'Demo for Fermat Attack'
m1 = bytes_to_long(b"Demo for Fermat Attack")

def isqrt(n):
    x = n
    y = (x + n // x) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x


def fermat(n):
    a = isqrt(n)
    b2 = a*a - n
    b = isqrt(n)
    count = 0
    while b*b != b2:
        a = a + 1
        b2 = a*a - n
        b = isqrt(b2)
        count += 1
    p = a+b
    q = a-b
    assert n == p * q
    return p, q


def main():
    n = 163325259729739139586456854939342071588766536976661696628405612100543978684304953042431845499808366612030757037530278155957389217094639917994417350499882225626580260012564702898468467277918937337494297292631474713546289580689715170963879872522418640251986734692138838546500522994170062961577034037699354013013
    p, q = fermat(n)
    print ("p =", p)
    print ("q=", q)
    n = p*q
    e = 65537
    phiN = (p-1)*(q-1)
    d = inverse(e, phiN)
    c = pow(m1,e,n)
    plain = pow(c,d,n)
    print("The plaintext is:", long_to_bytes(plain))

if __name__ == '__main__':
    main()

# bruteforce e small RSA
import gmpy2

n= 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e= 3
c= 1392110946977426581210288872807509251392076497351987505896089950162692810051896232983648644421803615199009722915837308898268143130185748969539756465922991390988577725714915452149385442135952885839362714303250186886978921094165493992414409734011784753153405390047687031061325298066760021966880485065590538743723301011115429078197449688949774786856876608360919146762028875279021241131831794983665516122651928479115559091151321734582289595283803647251924129179258914908399603428446300260249786155480450948868881391759044412921327748912001193897684527875543029625111137624422149702225350733227680058447222388856929481275430890359109824665638618290105585442788866367317567026455578522052309302485663517768671236586862095512112352204928702369687497533725812684849145517329825711597092963861957634018855564925281809184233866669420770666312705368062859749122506783539801286710836740679074133531045443384047588342891675611531850034064778808905808779758702547543061448191040299935545609883912652942748534956804321395
for i in range(10000000):
    m, is_true_root = gmpy2.iroot(i*n + c, e)
    if is_true_root:
        print(f"Found i = {i}")
        print("Message: {}".format(bytearray.fromhex(format(m, 'x')).decode()))
        break

# sagemath - Low-Dimensional Attacks 
m = 0x596f7520686176652073756368206120736d616c6c207765696e65722e2049204841544520594f5521212121
N = 0x26553fbb7e4bd5bd48868a25f24d9cc5975aa8597f82110058e687dfa10dd0114c0d2011fa288dbd9d01c0a70dfa8212d5a218d513bdd8ebed9f75bc299e1461be8a23ed8ade96bc449d409fbbf5a328ee2ad3257e6c55a97641258730f74f4d3938f0df794546791ba2b1518b8d855e83f65f885d67aa000a01687ac605404e7bca681e51e6e195f77eb4785fcda0372e3d0fd90240f736243584677f89da4c6ab54d687897d5afb0801cc151c516b072aaa2d9aa8d39d34c230536cba077beaa88ff8e8940a5ba990cafd0b1326f209873a43a785d0c5477241fb6469b8c27c7d54908467a7525de18b2425901c0de3ed63472831c29818ce6efb0354c61f36b2e61146472e99209d198bc885ced0edb66eab62a968c9b98b49b756c689d69820ca1d97e1232c338084097078265ce79b25c1e37bc777247af3fee2ce7a87a697a120c0428327177cf6e934aa2d18e696474227d361a5c36992788c3b1aa8654b88852e897027d58b21576b25a5ffdcb9fbdc5167eb74f1c9082ae79ca0b89
e = 0xfc2e4d12eb69a42c074d9a0ddc6b84294f1e23d6eaa0ba53e9cb60ec0db203d31bdfb90eaca38189890ad26335ad6107cd234a415bfc73fc1bbd6c5d9da65249eebb57d889f91719cfdbd535ab19d2d317ffdf075870a62c6e05aac16c9b122e1c52d7dbeb2fb683514d0f463b58a4217f2e379e5a62be06e764e043a0eac5ac6af56816af926bcc4cd826ee1cfd4157496dc024042676503cec93de45c3c5e4dd9dcf85406a3cf93a9f784b9eef6e320cd9856aefff48df52127b98da8a0d207f588ce1c58e47419554590b1fa7fa3c38034f93a3a5112b6dd5e78c181abc2d972fbcb058575789c68c03f043bd4bf48d94fa7390c77f9fc033f3f01a5162d31056eb42a07397f3485b25396f93558466fc49ef80adea1e9d6c3d9edf529be5faf014669ae5f8e02433a2474d9c92fcc468d81aa0fd641a5647d55153713783a9e5d66fe70c9c2794325b28f20b751fb49359c4a8487bbfa7efc6270b7fa0ffe277276bba14027596d129fcbdef0a82aba24855bfd2155071b52c11da2d943
c = pow(m,e,N)
s = floor(sqrt(N))
M = Matrix([[e, s], [N, 0]])
vector= M.LLL()
D = [abs(vector[i, 1]) // s for i in [0,1]]
for d in D:
    if pow(c,d,N) == m:
        print(d)